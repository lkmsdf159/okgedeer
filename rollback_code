//롤백코드
// 웹 앱으로 접근 시 실행되는 함수
function doGet(e) {
  // URL 쿼리 파라미터로 페이지 구분 (page=admin이면 관리자 페이지)
  const page = e && e.parameter && e.parameter.page ? e.parameter.page : '';
  
  if (page === 'worklog') {
    return HtmlService.createTemplateFromFile('Dashboard')
      .evaluate()
      .setTitle('근무  대시보드')
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
  } else {
    // 기본 출퇴근 기록 앱
    return HtmlService.createTemplateFromFile('Index')
      .evaluate()
      .setTitle('알바 출퇴근 시스템')
      .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
  }
}

// 직원 목록 가져오기 (시급 정보 포함)
function getEmployees() {
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('직원목록');
    if (!sheet) return [];
    
    const data = sheet.getDataRange().getValues();
    const employees = [];
    
    if (data.length <= 1) return employees;
    
    // 헤더 확인
    const headers = data[0];
    const hourlyRateColumn = headers.indexOf('시급');
    const passwordColumn = headers.indexOf('비밀번호');
    
    // 헤더를 제외한 행 처리
    for (let i = 1; i < data.length; i++) {
      if (data[i][0]) { // 이름이 있는 경우만 추가
        const employee = {
          name: data[i][0],
          id: i
        };
        
        // 시급 정보가 있으면 추가
        if (hourlyRateColumn !== -1 && data[i][hourlyRateColumn]) {
          employee.hourlyRate = parseInt(data[i][hourlyRateColumn]);
        } else {
          employee.hourlyRate = 9860; // 최저시급 기본값
        }
        
        // 보안을 위해 비밀번호는 클라이언트에게 전송하지 않음
        employees.push(employee);
      }
    }
    
    return employees;
  } catch (e) {
    Logger.log(`getEmployees 오류: ${e}`);
    return [];
  }
}

// 비밀번호 검증 함수
function verifyEmployeePassword(employeeName, password) {
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('직원목록');
    if (!sheet) {
      return {
        success: false,
        message: '직원목록 시트를 찾을 수 없습니다.'
      };
    }
    
    const data = sheet.getDataRange().getValues();
    
    if (data.length <= 1) {
      return {
        success: false,
        message: '직원 정보가 없습니다.'
      };
    }
    
    // 헤더 확인
    const headers = data[0];
    const nameColumn = headers.indexOf('이름') !== -1 ? headers.indexOf('이름') : 0;
    const passwordColumn = headers.indexOf('비밀번호');
    
    if (passwordColumn === -1) {
      return {
        success: false,
        message: '비밀번호 정보가 시트에 없습니다.'
      };
    }
    
    // 직원 찾기
    let found = false;
    let passwordCorrect = false;
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][nameColumn] === employeeName) {
        found = true;
        // 비밀번호 검증 (문자열로 변환하여 비교)
        const storedPassword = String(data[i][passwordColumn]);
        if (storedPassword === String(password)) {
          passwordCorrect = true;
        }
        break;
      }
    }
    
    if (!found) {
      return {
        success: false,
        message: '해당 이름의 직원을 찾을 수 없습니다.'
      };
    }
    
    if (!passwordCorrect) {
      return {
        success: false,
        message: '비밀번호가 일치하지 않습니다.'
      };
    }
    
    return {
      success: true,
      message: '비밀번호 확인 완료'
    };
    
  } catch (e) {
    Logger.log(`verifyEmployeePassword 오류: ${e.stack || e.toString()}`);
    return {
      success: false,
      message: `비밀번호 검증 중 오류가 발생했습니다: ${e.message}`
    };
  }
}

// 출퇴근 기록 처리 함수 - 비밀번호 검증 추가
function recordAttendanceWithPassword(employeeName, password, type) {
  try {
    // 비밀번호 검증
    const verification = verifyEmployeePassword(employeeName, password);
    
    if (!verification.success) {
      return verification; // 비밀번호 검증 실패 결과 반환
    }
    
    // 비밀번호 검증 성공 시 출퇴근 기록 처리
    return recordAttendance(employeeName, type);
    
  } catch (e) {
    Logger.log(`recordAttendanceWithPassword 오류: ${e.stack || e.toString()}`);
    return {
      success: false,
      message: `출퇴근 처리 중 오류가 발생했습니다: ${e.message}`,
      timestamp: new Date().toString()
    };
  }
}

// 출퇴근 기록 처리 함수 - 개선된 버전
function recordAttendance(employeeName, type) {
  try {
    const now = new Date();
    const currentMonth = now.getMonth() + 1;
    
    // 현재 월의 출퇴근기록 시트 가져오기
    const sheet = getAttendanceSheet(currentMonth);
    
    if (!sheet) {
      return {
        success: false,
        message: '출퇴근기록 시트를 찾을 수 없습니다.'
      };
    }

    // 10분 단위로 반올림/내림
    const roundedTime = roundTimeToTenMinutes(now);
    const currentTime = Utilities.formatDate(roundedTime, 'Asia/Seoul', 'HH:mm');
    
    // 헤더 데이터 가져오기 (직원 이름 행과 열 헤더 행)
    const headerRows = sheet.getRange(1, 1, 2, sheet.getLastColumn()).getValues();
    const employeeRow = headerRows[0];
    const columnTypesRow = headerRows[1];

    // 직원의 열 찾기
    let employeeStartCol = -1;
    for(let i = 2; i < employeeRow.length; i += 3) {
      if(employeeRow[i] === employeeName) {
        employeeStartCol = i + 1;  // +1 because getRange is 1-based
        break;
      }
    }

    if(employeeStartCol === -1) {
      return {
        success: false,
        message: '직원 정보를 찾을 수 없습니다.'
      };
    }

    // 오늘 날짜의 행 찾기
    const today = Utilities.formatDate(now, 'Asia/Seoul', 'yyyy-MM-dd');
    const dateColumn = sheet.getRange(3, 1, sheet.getLastRow(), 1).getValues();
    let todayRow = -1;

    for(let i = 0; i < dateColumn.length; i++) {
      if(dateColumn[i][0] instanceof Date) {
        const rowDate = Utilities.formatDate(dateColumn[i][0], 'Asia/Seoul', 'yyyy-MM-dd');
        if(rowDate === today) {
          todayRow = i + 3;  // +3 because we start from row 3 and getRange is 1-based
          break;
        }
      }
    }

    if(todayRow === -1) {
      return {
        success: false,
        message: '오늘 날짜를 시트에서 찾을 수 없습니다.'
      };
    }

    // 출근/퇴근 처리
    if(type === '출근') {
      // 이미 출근했는지 확인
      const checkInValue = sheet.getRange(todayRow, employeeStartCol).getValue();
      if(checkInValue && checkInValue !== '미출근') {
        return {
          success: false,
          message: `${employeeName}님은 오늘 이미 출근 처리되었습니다.`,
          timestamp: roundedTime.toString()
        };
      }

      // 출근 시간 입력
      sheet.getRange(todayRow, employeeStartCol).setValue(currentTime);
      
    } else if(type === '퇴근') {
      // 출근 여부 확인
      const checkInValue = sheet.getRange(todayRow, employeeStartCol).getValue();
      const checkOutValue = sheet.getRange(todayRow, employeeStartCol + 1).getValue();

      if(!checkInValue || checkInValue === '미출근') {
        // 출근 기록이 없는 경우
        sheet.getRange(todayRow, employeeStartCol).setValue('미출근');
        sheet.getRange(todayRow, employeeStartCol + 1).setValue(currentTime);
        return {
          success: true,
          message: `${employeeName}님 퇴근 처리 완료 (${currentTime}) - 출근 기록이 없습니다.`,
          timestamp: roundedTime.toString()
        };
      }

      if(checkOutValue && checkOutValue !== '미퇴근') {
        return {
          success: false,
          message: `${employeeName}님은 오늘 이미 퇴근 처리되었습니다.`,
          timestamp: roundedTime.toString()
        };
      }

      // 퇴근 시간 입력
      sheet.getRange(todayRow, employeeStartCol + 1).setValue(currentTime);
    }

    return {
      success: true,
      message: `${employeeName}님 ${type} 처리 완료 (${currentTime})`,
      timestamp: roundedTime.toString()
    };

  } catch (e) {
    Logger.log(`recordAttendance 오류: ${e.stack || e.toString()}`);
    return {
      success: false,
      message: '출퇴근 기록 중 오류가 발생했습니다.'
    };
  }
}

// 1. 근무시간 계산 수식 생성 함수
function createWorkingHoursFormula(checkInCell, checkOutCell) {
  return `=IF(AND(NOT(ISBLANK(${checkInCell})), NOT(ISBLANK(${checkOutCell})), ${checkInCell}<>"미출근", ${checkOutCell}<>"미퇴근"), 
    IF((HOUR(${checkOutCell}) + MINUTE(${checkOutCell})/60) < (HOUR(${checkInCell}) + MINUTE(${checkInCell})/60),
      (HOUR(${checkOutCell}) + MINUTE(${checkOutCell})/60) + 24 - (HOUR(${checkInCell}) + MINUTE(${checkInCell})/60),
      (HOUR(${checkOutCell}) + MINUTE(${checkOutCell})/60) - (HOUR(${checkInCell}) + MINUTE(${checkInCell})/60)
    ),
    0)`;
}


// 직원 열 설정 모듈
function setupEmployeeColumns(sheet, employee, startCol, dataRows, totalRow) {
  // 1. 직원 이름 헤더 설정 - 병합 적용
  sheet.getRange(1, startCol, 1, 3).merge();
  sheet.getRange(1, startCol).setValue(employee.name);
  sheet.getRange(1, startCol, 1, 3).setHorizontalAlignment('center');
  sheet.getRange(1, startCol, 1, 3).setFontWeight('bold');
  sheet.getRange(1, startCol, 1, 3).setBorder(true, true, true, true, true, true);
  sheet.getRange(1, startCol, 1, 3).setBackground('#f3f3f3'); // 헤더 회색 배경 추가
  
  // 2. 열 헤더 명확하게 설정
  sheet.getRange(2, startCol).setValue('출근시간').setFontWeight('bold').setBackground('#f3f3f3').setBorder(true, true, true, true, true, true);
  sheet.getRange(2, startCol + 1).setValue('퇴근시간').setFontWeight('bold').setBackground('#f3f3f3').setBorder(true, true, true, true, true, true);
  sheet.getRange(2, startCol + 2).setValue('근무시간').setFontWeight('bold').setBackground('#f3f3f3').setBorder(true, true, true, true, true, true);
  
  // 3. 출퇴근 시간 열 서식 설정
  sheet.getRange(3, startCol, dataRows, 2).setNumberFormat('HH:mm');
  
  // 4. 근무시간 열에 수식 추가
  for (let row = 3; row < totalRow; row++) {
    const checkInCell = sheet.getRange(row, startCol).getA1Notation();
    const checkOutCell = sheet.getRange(row, startCol + 1).getA1Notation();
    
    const formula = createWorkingHoursFormula(checkInCell, checkOutCell);
    sheet.getRange(row, startCol + 2).setFormula(formula);
    sheet.getRange(row, startCol + 2).setNumberFormat('0.00');
  }
  
  // 5. 총 근무시간 행 수식 추가
  const totalHoursFormula = `=SUM(${getColumnLetter(startCol + 2)}3:${getColumnLetter(startCol + 2)}${totalRow - 1})`;
  sheet.getRange(totalRow, startCol + 2).setFormula(totalHoursFormula);
  sheet.getRange(totalRow, startCol + 2).setFontWeight('bold');
  sheet.getRange(totalRow, startCol + 2).setNumberFormat('0.00');
  
  return startCol + 3; // 다음 직원의 시작 열 반환
}


// 함수를 통합
function createEmployeeSummarySection(sheet, employee, startRow, startCol) {
  try {
    // 직원 이름 헤더 - 병합 적용
    sheet.getRange(startRow, startCol, 1, 3).merge();
    sheet.getRange(startRow, startCol).setValue(employee.name);
    sheet.getRange(startRow, startCol, 1, 3).setHorizontalAlignment('center');
    sheet.getRange(startRow, startCol).setFontWeight('bold');
    sheet.getRange(startRow, startCol, 1, 3).setBorder(true, true, true, true, true, true);
    
    // 각 행 정보 설정 (시급, 구분, 주차별 데이터 등)
    const rows = [
      ['시급', '', employee.hourlyRate || 9860],
      ['구분', '시간', '금액'],
      ['1주차', 0, '₩0'],
      ['2주차', 0, '₩0'],
      ['3주차', 0, '₩0'],
      ['4주차', 0, '₩0'],
      ['5주차', 0, '₩0'],
      ['주차별 주휴', '주차별 합계', '3.3%'],
      ['', '₩0', '₩0'],
      ['', '₩0', '₩0'],
      ['', '₩0', '₩0'],
      ['', '₩0', '₩0'],
      ['', '₩0', '₩0'],
      ['주휴합', '총합', '3.3%합'],
      ['₩0', '₩0', '₩0'],
      ['', '', '지급액'],
      ['', '', '₩0']
    ];
    
    // 데이터 입력
    for (let i = 0; i < rows.length; i++) {
      for (let j = 0; j < rows[i].length; j++) {
        if (rows[i][j] !== '') {
          sheet.getRange(startRow + i + 1, startCol + j).setValue(rows[i][j]);
        }
      }
    }
    
    // 구분 행 강조
    sheet.getRange(startRow + 2, startCol, 1, 3).setBackground('#f3f3f3');
    
    // 주차별 주휴 행 배경색 설정
    sheet.getRange(startRow + 8, startCol, 1, 3).setBackground('#FFFF00');
    
    // 주유합/총합 행 배경색 설정
    sheet.getRange(startRow + 14, startCol, 1, 3).setBackground('#FFFF00');
    
    // 지급액 행 배경색 설정
    sheet.getRange(startRow + 16, startCol + 2).setBackground('#FFFF00');
    
    // 시급 셀 서식
    sheet.getRange(startRow + 1, startCol + 2).setNumberFormat('#,##0');
    
    setupSummaryFormulas(sheet, employee, startRow, startCol);
    
  } catch (e) {
    Logger.log(`createEmployeeSummarySection 오류: ${e.toString()}`);
  }
}

// 기본 시트 구조 생성 모듈
function setupBasicSheetStructure(sheet, date) {
  // 열 너비 설정
  sheet.setColumnWidth(1, 100); // 날짜 열
  sheet.setColumnWidth(2, 60);  // 요일 열
  
  // 날짜/요일 헤더 설정
  sheet.getRange(1, 1).setValue('날짜');
  sheet.getRange(1, 2).setValue('요일');
  sheet.getRange(1, 1, 2, 1).merge();
  sheet.getRange(1, 2, 2, 1).merge();
  
  // 날짜 채우기
  const lastDay = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
  const dates = [];
  for (let i = 1; i <= lastDay; i++) {
    const currentDate = new Date(date.getFullYear(), date.getMonth(), i);
    const dayNames = ['일', '월', '화', '수', '목', '금', '토'];
    const dayOfWeek = dayNames[currentDate.getDay()];
    
    // 주차 계산
    const weekOfMonth = Math.ceil(i / 7);
    dates.push([
      currentDate,
      `${dayOfWeek} (${weekOfMonth}주)`
    ]);
  }
  
  // 날짜 데이터 입력 및 서식 설정
  const dateRange = sheet.getRange(3, 1, dates.length, 2);
  dateRange.setValues(dates);
  sheet.getRange(3, 1, dates.length, 1).setNumberFormat('yyyy-MM-dd');
  sheet.getRange(3, 2, dates.length, 1).setHorizontalAlignment('center');
  
  // 총 근무시간 행 추가
  const totalRow = dates.length + 3;
  sheet.getRange(totalRow, 1).setValue('총시간');
  sheet.getRange(totalRow, 1, 1, 2).merge();
  sheet.getRange(totalRow, 1).setFontWeight('bold');
  
  return {
    lastDay: lastDay,
    totalRow: totalRow,
    summaryRow: totalRow + 2
  };
}

// 요약 섹션 수식 설정 함수
function setupSummaryFormulas(sheet, employee, startRow, startCol) {
  try {
    // 주차별 시간 계산 수식 설정
    for (let week = 1; week <= 5; week++) {
      const weekRow = startRow + 2 + week;
      
      // 중요: 근무시간 열은 startCol + 2입니다 (출근시간, 퇴근시간, 근무시간 순서이므로)
      const hourColumn = startCol + 2;
      const hourColumnLetter = getColumnLetter(hourColumn);
      
      // 주차별 근무시간 합계 계산 (해당 주차의 데이터만 합산)
      const hoursFormula = `=SUMIFS(${hourColumnLetter}3:${hourColumnLetter}${startRow - 3}, B3:B${startRow - 3}, "*${week}주*")`;
      sheet.getRange(weekRow, startCol + 1).setFormula(hoursFormula);
      sheet.getRange(weekRow, startCol + 1).setNumberFormat('0.0');
      
      // 금액 계산 수식 (시간 * 시급)
      const salaryFormula = `=${getColumnLetter(startCol + 1)}${weekRow}*${getColumnLetter(startCol + 2)}${startRow + 1}`;
      sheet.getRange(weekRow, startCol + 2).setFormula(salaryFormula);
      sheet.getRange(weekRow, startCol + 2).setNumberFormat('#,##0');
      
      // 주차별 주휴수당 및 세금 계산
      const taxRow = startRow + 8 + week;
      
      sheet.getRange(taxRow, startCol).setNumberFormat('#,##0');

      // 주차별 급여 참조
      sheet.getRange(taxRow, startCol + 1).setFormula(`=${getColumnLetter(startCol + 2)}${weekRow} + ${getColumnLetter(startCol)}${taxRow}`);
      sheet.getRange(taxRow, startCol + 1).setNumberFormat('#,##0');
      
      // 3.3% 세금 계산
      sheet.getRange(taxRow, startCol + 2).setFormula(`=${getColumnLetter(startCol + 1)}${taxRow}*0.033`);
      sheet.getRange(taxRow, startCol + 2).setNumberFormat('#,##0');
    }
    
    // 주유합 계산 (모든 주차 주휴수당의 합)
    const bonusSum = `=SUM(${getColumnLetter(startCol)}${startRow + 9}:${getColumnLetter(startCol)}${startRow + 13})`;
    sheet.getRange(startRow + 15, startCol).setFormula(bonusSum);
    sheet.getRange(startRow + 15, startCol).setNumberFormat('#,##0');
    
    // 총합 계산 (주차별 합계의 총액)
    const totalSum = `=SUM(${getColumnLetter(startCol + 1)}${startRow + 9}:${getColumnLetter(startCol + 1)}${startRow + 13})`;
    sheet.getRange(startRow + 15, startCol + 1).setFormula(totalSum);
    sheet.getRange(startRow + 15, startCol + 1).setNumberFormat('#,##0');
    
    // 3.3% 세금 총액
    const taxSum = `=SUM(${getColumnLetter(startCol + 2)}${startRow + 9}:${getColumnLetter(startCol + 2)}${startRow + 13})`;
    sheet.getRange(startRow + 15, startCol + 2).setFormula(taxSum);
    sheet.getRange(startRow + 15, startCol + 2).setNumberFormat('#,##0');
    
    // 최종 지급액 계산 (총합 - 3.3% 세금)
    const finalAmount = `=${getColumnLetter(startCol + 1)}${startRow + 15} - ${getColumnLetter(startCol + 2)}${startRow + 15}`;
    sheet.getRange(startRow + 17, startCol + 2).setFormula(finalAmount);
    sheet.getRange(startRow + 17, startCol + 2).setNumberFormat('#,##0');
    sheet.getRange(startRow + 17, startCol + 2).setFontWeight('bold');
    
    
    return true;
  } catch (e) {
    Logger.log(`setupSummaryFormulas 오류: ${e.toString()}`);
    return false;
  }
}

// 2. 시트 구조 분석 함수
function analyzeSheetStructure(sheet) {
  // 헤더 행 가져오기
  const headerRow = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const colHeaderRow = sheet.getRange(2, 1, 1, sheet.getLastColumn()).getValues()[0];
  
  const existingEmployees = [];
  const employeeColumns = {}; // 직원 이름 -> 시작 열 번호 매핑
  
  // 직원 열 찾기
  for (let col = 1; col < headerRow.length; col++) {
    const empName = headerRow[col];
    if (empName && !['날짜', '요일'].includes(empName)) {
      const colHeader = colHeaderRow[col];
      if (colHeader === '출근시간') {
        existingEmployees.push(empName);
        employeeColumns[empName] = col + 1; // 1-based
      }
    }
  }
  
  // 총시간 행과 요약 행 찾기 로직
  let totalRow = -1;
  let summaryRow = -1;
  const allData = sheet.getDataRange().getValues();
  
  // 총시간 행 찾기
  for (let row = 0; row < allData.length; row++) {
    if (allData[row][0] === '총시간') {
      totalRow = row + 1; // 1-based
      break;
    }
  }
  
  // 총시간 행을 찾지 못했을 때 대체 로직
  if (totalRow === -1) {
    for (let row = allData.length - 1; row >= 0; row--) {
      if (allData[row][0] instanceof Date) {
        totalRow = row + 2; // 날짜 다음 행
        break;
      }
    }
    
    if (totalRow === -1) {
      totalRow = allData.length > 3 ? allData.length : 34; // 한 달 기준
    }
  }
  
  // 요약 정보 시작 행 찾기
  for (let row = 0; row < allData.length; row++) {
    if (allData[row][0] === '근무 요약 정보') {
      summaryRow = row + 1;
      break;
    }
  }
  
  if (summaryRow === -1) {
    summaryRow = totalRow + 2;
  }
  
  return {
    existingEmployees,
    employeeColumns, 
    totalRow,
    summaryRow
  };
}

function syncEmployeesForMonth(month) {
  try {
    // 월 파라미터가 없으면 현재 월 사용
    if (!month) {
      const now = new Date();
      month = now.getMonth() + 1;
    }
    
    Logger.log(`${month}월 시트 직원 동기화 시작...`);
    
    // 직원 목록 가져오기
    const employees = getEmployees();
    
    // 해당 월 시트 찾기
    const sheetName = `${month}월_출퇴근기록`;
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(sheetName);
    
    if (!sheet) {
      Logger.log(`${sheetName} 시트를 찾을 수 없습니다.`);
      return `${sheetName} 시트를 찾을 수 없습니다.`;
    }
    
    // 현재 시트에 있는 직원 및 구조 분석 (이 함수는 위에서 새로 만든 것)
    const { existingEmployees, employeeColumns, totalRow, summaryRow } = analyzeSheetStructure(sheet);
    
    // 추가할 직원 목록 생성 (기존에 없는 직원만)
    const employeesToAdd = employees.filter(emp => !existingEmployees.includes(emp.name));
    
    // 변경 사항이 없으면 종료
    if (employeesToAdd.length === 0) {
      return `${month}월 시트에 변경 사항이 없습니다.`;
    }
    
    // 마지막 직원 열 위치 찾기
    let lastColumn = 2; // 날짜, 요일 열
    for (const empName in employeeColumns) {
      const startCol = employeeColumns[empName];
      lastColumn = Math.max(lastColumn, startCol + 2); // 각 직원은 3열 사용
    }
    
    // 새 직원 추가
    for (const employee of employeesToAdd) {
      // 다음 직원 위치는 마지막 열 다음
      const newStartCol = lastColumn + 1;
      
      // 직원 열 설정 (이 함수는 위에서 새로 만든 것)
      setupEmployeeColumns(sheet, employee, newStartCol, totalRow - 3, totalRow);
      
      // 요약 섹션 추가 (이 함수는 위에서 새로 만든 것)
      createEmployeeSummarySection(sheet, employee, summaryRow, newStartCol);
      
      // 다음 직원을 위해 마지막 열 위치 업데이트
      lastColumn = newStartCol + 2;
    }
    
    return `${month}월 시트 직원 동기화 완료! ${employeesToAdd.length}명의 직원이 추가되었습니다.`;
    
  } catch (e) {
    const errorMsg = `${month}월 시트 동기화 오류: ${e.toString()}`;
    Logger.log(errorMsg);
    return errorMsg;
  }
}

function createMonthlySheet() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const today = new Date();
    const targetMonth = today.getMonth() + 1;
    
    // 시트 이름 생성
    const sheetName = `${targetMonth}월_출퇴근기록`;
    
    // 이미 존재하는지 확인
    if (ss.getSheetByName(sheetName)) {
      Logger.log(`${sheetName} 시트가 이미 존재합니다.`);
      return;
    }
    
    // 새 시트 생성
    Logger.log(`${sheetName} 시트 생성 시작...`);
    const newSheet = ss.insertSheet(sheetName);
    
    newSheet.insertColumnsAfter(newSheet.getMaxColumns(), 100);

    // 기본 시트 구조 설정 (이 함수는 위에서 새로 만든 것)
    const { lastDay, totalRow, summaryRow } = setupBasicSheetStructure(newSheet, today);
    
    // 직원 목록 가져오기
    const employees = getEmployees();
    
    // 직원별 열 추가 (이 함수는 위에서 새로 만든 것)
    let nextCol = 3; // 날짜, 요일 다음부터 시작
    for (const employee of employees) {
      nextCol = setupEmployeeColumns(newSheet, employee, nextCol, lastDay, totalRow);
    }
    
    // 요약 정보 섹션 헤더 추가
    newSheet.getRange(summaryRow, 1).setValue('근무 요약 정보');
    
    // 직원별 요약 섹션 추가 (이 함수는 위에서 새로 만든 것)
    nextCol = 3; // 다시 처음부터
    for (const employee of employees) {
      createEmployeeSummarySection(newSheet, employee, summaryRow, nextCol);
      nextCol += 3;
    }
    
    // 데이터 유효성 검사 규칙 설정 (기존 함수 사용)
    setupValidationRules(newSheet, lastDay);
    
    Logger.log(`${sheetName} 시트가 성공적으로 생성되었습니다.`);
    
  } catch (error) {
    Logger.log(`시트 생성 중 오류 발생: ${error.toString()}`);
  }
}

// 시트의 기본 구조 설정 
function setupSheetStructure(sheet, date) {
  try {
    // 직원 목록 가져오기
    const employees = getEmployees();
    const lastDay = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
    
    // 열 너비 설정
    sheet.setColumnWidth(1, 100); // 날짜 열
    sheet.setColumnWidth(2, 60);  // 요일 열
    
    // 기본 헤더 설정 (날짜, 요일)
    let headers = ['날짜', '요일'];
    let employeeHeaders = []; // 직원 이름 행
    let columnHeaders = []; // 출근/퇴근/근무시간 행
    
    // 직원별 헤더 구성
    employees.forEach(emp => {
      // 직원 이름은 3열을 병합
      employeeHeaders.push(emp.name, '', '');
      columnHeaders.push('출근시간', '퇴근시간', '근무시간');
      
      // 각 직원의 열 너비 설정 (출근/퇴근/근무시간)
      const startCol = headers.length;
      sheet.setColumnWidths(startCol + 1, 3, 80);
      
      headers.push('', '', ''); // 빈 열 추가
    });
    
    // 헤더 설정
    const headerRange = sheet.getRange(1, 1, 2, headers.length);
    
    // 첫 번째 행: 날짜/요일 + 직원 이름
    const firstRow = ['날짜', '요일'].concat(employeeHeaders);
    // 두 번째 행: 빈칸 + 출근/퇴근/근무시간
    const secondRow = ['', ''].concat(columnHeaders);
    
    headerRange.setValues([firstRow, secondRow]);
    
    // 직원 이름 병합
    employees.forEach((emp, index) => {
      const startCol = 3 + (index * 3);
      sheet.getRange(1, startCol, 1, 3).merge();
    });
    
    // 날짜/요일 병합
    sheet.getRange(1, 1, 2, 1).merge();
    sheet.getRange(1, 2, 2, 1).merge();
    
    // 헤더 서식 설정 및 테두리
    headerRange
      .setBackground('#f3f3f3')
      .setFontWeight('bold')
      .setHorizontalAlignment('center')
      .setVerticalAlignment('middle')
      .setBorder(true, true, true, true, true, true);  // 헤더의 모든 테두리
    
    // 날짜 채우기
    const dates = [];
    for (let i = 1; i <= lastDay; i++) {
      const currentDate = new Date(date.getFullYear(), date.getMonth(), i);
      const dayNames = ['일', '월', '화', '수', '목', '금', '토'];
      const dayOfWeek = dayNames[currentDate.getDay()];
      
      // 주차 계산 (1일부터 7일까지는 1주차, 8일부터 14일까지는 2주차...)
      const weekOfMonth = Math.ceil(i / 7);
      
      dates.push([
        currentDate,  // Date 객체 그대로 전달
        `${dayOfWeek} (${weekOfMonth}주)`
      ]);
    }
    
    // 날짜 데이터 입력 및 서식 설정
    const dateRange = sheet.getRange(3, 1, dates.length, 2);
    dateRange.setValues(dates);
    
    // 날짜 열 서식 설정
    sheet.getRange(3, 1, dates.length, 1).setNumberFormat('yyyy-MM-dd');
    
    // 요일 열 중앙 정렬
    sheet.getRange(3, 2, dates.length, 1).setHorizontalAlignment('center');

    // 직원별 시간 열 서식 설정
    employees.forEach((emp, index) => {
      const startCol = 3 + (index * 3);
      const timeRange = sheet.getRange(3, startCol, dates.length, 2); // 출근/퇴근 시간 열
      timeRange.setNumberFormat('HH:mm');
      
      // 근무시간 열에 수식 설정 (시간 계산)
      for (let i = 0; i < dates.length; i++) {
        const row = i + 3;
        const checkInCell = sheet.getRange(row, startCol).getA1Notation();
        const checkOutCell = sheet.getRange(row, startCol + 1).getA1Notation();
        
        // 근무시간 계산 수식 (출퇴근 시간이 모두 있는 경우에만 계산)
        // 퇴근 시간이 출근 시간보다 이른 경우(다음날 퇴근) 처리 추가
        const formula = `=IF(AND(NOT(ISBLANK(${checkInCell})), NOT(ISBLANK(${checkOutCell})), ${checkInCell}<>"미출근", ${checkOutCell}<>"미퇴근"), 
          IF((HOUR(${checkOutCell}) + MINUTE(${checkOutCell})/60) < (HOUR(${checkInCell}) + MINUTE(${checkInCell})/60),
            (HOUR(${checkOutCell}) + MINUTE(${checkOutCell})/60) + 24 - (HOUR(${checkInCell}) + MINUTE(${checkInCell})/60),
            (HOUR(${checkOutCell}) + MINUTE(${checkOutCell})/60) - (HOUR(${checkInCell}) + MINUTE(${checkInCell})/60)
          ),
          0)`;
        
        sheet.getRange(row, startCol + 2).setFormula(formula);
        sheet.getRange(row, startCol + 2).setNumberFormat('0.0');
      }
    });
    
    // 총 근무시간 행 추가 (마지막 날짜 아래)
    const summaryRow = dates.length + 3;
    sheet.getRange(summaryRow, 1).setValue('총시간');
    sheet.getRange(summaryRow, 1, 1, 2).merge();
    sheet.getRange(summaryRow, 1).setFontWeight('bold');
    
    // 직원별 총 근무시간 계산
    employees.forEach((emp, index) => {
      const startCol = 3 + (index * 3);
      const totalHoursFormula = `=SUM(${getColumnLetter(startCol + 2)}3:${getColumnLetter(startCol + 2)}${summaryRow - 1})`;
      sheet.getRange(summaryRow, startCol + 2).setFormula(totalHoursFormula);
      sheet.getRange(summaryRow, startCol + 2).setFontWeight('bold');
      sheet.getRange(summaryRow, startCol + 2).setNumberFormat('0.0');
    });
    
    // 이미지와 같은 구조의 요약 정보 생성
    createSummarySection(sheet, employees, summaryRow);
    
    // 데이터 유효성 검사 규칙 설정 (출퇴근 시간 열에만 적용)
    setupValidationRules(sheet, dates.length);
    
    return true;
  } catch (e) {
    Logger.log(`setupSheetStructure 오류: ${e}`);
    return false;
  }
}

//근무 요약 정보 섹션 생성
function createSummarySection(sheet, employees, startRow) {
  try {
    // '근무 요약 정보' 헤더 추가
    sheet.getRange(startRow, 1).setValue('근무 요약 정보');
    
    // 직원별 요약 섹션 생성
    employees.forEach((emp, index) => {
      const startCol = index * 3 + 3;
      
      // 직원 이름 헤더 생성
      sheet.getRange(startRow, startCol, 1, 3).merge();
      sheet.getRange(startRow, startCol).setValue(emp.name);
      sheet.getRange(startRow, startCol).setHorizontalAlignment('center');
      sheet.getRange(startRow, startCol).setFontWeight('bold');
      sheet.getRange(startRow, startCol, 1, 3).setBorder(true, true, true, true, true, true);
      
      // 각 행 정보 설정 (시급, 구분, 주차별 데이터)
      const rows = [
        ['시급', '', emp.hourlyRate || 9860],
        ['구분', '시간', '금액'],
        ['1주차', 0, '₩0'],
        ['2주차', 0, '₩0'],
        ['3주차', 0, '₩0'],
        ['4주차', 0, '₩0'],
        ['5주차', 0, '₩0'],
        ['주차별 주휴', '주차별 합계', '3.3%'],
        ['', '₩0', '₩0'],
        ['', '₩0', '₩0'],
        ['', '₩0', '₩0'],
        ['', '₩0', '₩0'],
        ['', '₩0', '₩0'],
        ['주휴합', '총합', '3.3%합'],
        ['₩0', '₩0', '₩0'],
        ['', '', '지급액'],
        ['', '', '₩0']
      ];
      
      // 데이터 입력
      for (let i = 0; i < rows.length; i++) {
        for (let j = 0; j < rows[i].length; j++) {
          if (rows[i][j] !== '') {
            sheet.getRange(startRow + i + 1, startCol + j).setValue(rows[i][j]);
          }
        }
      }
      
      // 스타일 설정
      // 구분 행 강조
      sheet.getRange(startRow + 2, startCol, 1, 3).setBackground('#f3f3f3');
      // 주차별 주휴 행 배경색 설정
      sheet.getRange(startRow + 8, startCol, 1, 3).setBackground('#FFFF00');
      // 주유합/총합 행 배경색 설정
      sheet.getRange(startRow + 14, startCol, 1, 3).setBackground('#FFFF00');
      // 지급액 행 배경색 설정
      sheet.getRange(startRow + 16, startCol + 2).setBackground('#FFFF00');
      // 시급 셀 서식
      sheet.getRange(startRow + 1, startCol + 2).setNumberFormat('#,##0');
      
      // 수식 설정은 별도 함수로 위임
      setupSummaryFormulas(sheet, emp, startRow, startCol);
    });
    
    // 주휴수당 설명 추가
    const noticeRow = startRow + 18;
    sheet.getRange(noticeRow, 1, 1, 8).merge();
    sheet.getRange(noticeRow, 1).setFontStyle('italic');
    sheet.getRange(noticeRow, 1).setFontSize(9);

    return true;
  } catch (e) {
    Logger.log(`createSummarySection 오류: ${e}`);
    return false;
  }
}

// 이전/다음 월 시트 존재 여부 확인
function checkAdjacentMonthSheets(currentMonth) {
  const prevMonth = currentMonth === 1 ? 12 : currentMonth - 1;
  const nextMonth = currentMonth === 12 ? 1 : currentMonth + 1;
  
  const prevSheet = getAttendanceSheet(prevMonth);
  const nextSheet = getAttendanceSheet(nextMonth);
  
  return {
    hasPrevMonth: prevSheet !== null,
    hasNextMonth: nextSheet !== null
  };
}


function getSummaryData(year, month, employeeId) {

  try {
    // 매개변수 로깅
    Logger.log(`getSummaryData 호출: year=${year}, month=${month}, employeeId=${employeeId}`);
    
    // 월 계산 (JavaScript는 0부터 시작)
    const monthNumber = Number(month) + 1;
    Logger.log(`계산된 월: ${monthNumber}`);
    
    // 직원 요약 정보 가져오기
    const result = getEmployeeSummaryFromSheet(monthNumber, employeeId);
    
    // 결과 확인
    if (!result) {
      Logger.log("getEmployeeSummaryFromSheet에서 null 반환됨");
      return { error: "데이터를 가져올 수 없습니다." };
    }
    
    Logger.log(`getSummaryData 반환 데이터: 출석=${Object.keys(result.attendance || {}).length}개 항목`);
    return result;
  } catch (e) {
    Logger.log(`getSummaryData 오류: ${e.stack || e.toString()}`);
    return { 
      error: `데이터 처리 중 오류 발생: ${e.message}`,
      attendance: {},
      summary: { message: "오류 발생" } 
    };
  }
}


// 해당 월의 출퇴근기록 시트 찾기 - 완전히 재작성된 버전
function getAttendanceSheet(targetMonth) {
  try {
    if (!targetMonth) {
      Logger.log("targetMonth가 null 또는 undefined입니다");
      return null;
    }
    
    // 문자열 변환 및 숫자 확인
    const monthNumber = Number(targetMonth);
    if (isNaN(monthNumber) || monthNumber < 1 || monthNumber > 12) {
      Logger.log(`유효하지 않은 월: ${targetMonth}`);
      return null;
    }
    
    const monthStr = String(monthNumber).trim();
    Logger.log(`검색 중인 시트: ${monthStr}월_출퇴근기록`);
    
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const exactSheetName = `${monthStr}월_출퇴근기록`;
    const exactSheet = ss.getSheetByName(exactSheetName);
    
    if (exactSheet) {
      Logger.log(`시트 찾음: ${exactSheetName}`);
      return exactSheet;
    }
    
    // 시트 목록 로깅
    const allSheets = ss.getSheets();
    Logger.log("사용 가능한 시트 목록:");
    allSheets.forEach(sheet => Logger.log(sheet.getName()));
    
    Logger.log(`시트를 찾을 수 없음: ${exactSheetName}`);
    return null;
  } catch (e) {
    Logger.log(`getAttendanceSheet 오류: ${e.toString()}`);
    return null;
  }
}

// 시트에서 직원 요약 정보 가져오기 - 급여 정보 제외 버전
function getEmployeeSummaryFromSheet(monthNumber, employeeId) {
  Logger.log(`getEmployeeSummaryFromSheet 호출: month=${monthNumber}, employeeId=${employeeId}`);
  try {
    const sheet = getAttendanceSheet(monthNumber);
    
    if (!sheet) {
      return { error: `${monthNumber}월_출퇴근기록 시트를 찾을 수 없습니다.` };
    }

    // 직원 정보 가져오기
    const employees = getEmployees();
    const employee = employees.find(emp => emp.id == employeeId);
    if (!employee) {
      Logger.log(`직원 ID ${employeeId}에 해당하는 직원을 찾을 수 없습니다.`);
      return { error: `직원 정보를 찾을 수 없습니다.` };
    }

    // 시트의 모든 데이터 가져오기
    const data = sheet.getDataRange().getValues();
    
    // 1. 출퇴근 데이터 수집 (날짜별)
    const attendance = {};
    
    // 직원 열 찾기
    let employeeCol = -1;
    for (let col = 2; col < data[0].length; col += 3) {
      if (data[0][col] === employee.name) {
        employeeCol = col;
        break;
      }
    }
    
    if (employeeCol === -1) {
      return { error: `해당 월 시트에서 ${employee.name}님의 출퇴근 기록을 찾을 수 없습니다.` };
    }
    
    // 날짜 데이터 시작 위치 (일반적으로 3행부터)
    let dateStartRow = -1;
    for (let row = 0; row < data.length; row++) {
      if (data[row][0] instanceof Date) {
        dateStartRow = row;
        break;
      }
    }
    
    if (dateStartRow === -1) {
      return { error: `시트에서 날짜 데이터를 찾을 수 없습니다.` };
    }
    
    // 출퇴근 기록 수집 (날짜별)
    let workingDays = 0;
    let totalHours = 0;
    
    for (let row = dateStartRow; row < data.length; row++) {
      // 근무 요약 정보 섹션 시작되면 종료
      if (data[row][0] === '근무 요약 정보' || !data[row][0]) break;
      
      if (data[row][0] instanceof Date) {
        const date = data[row][0];
        const dateStr = Utilities.formatDate(date, 'Asia/Seoul', 'yyyy-MM-dd');
        
        let checkIn;
        if (data[row][employeeCol] instanceof Date) {
            const checkInDate = new Date(data[row][employeeCol]);
            checkInDate.setHours(checkInDate.getHours() + 1); // 한 시간 추가
            checkInDate.setMinutes(checkInDate.getMinutes() - 27); // 27분 빼기
            checkIn = Utilities.formatDate(checkInDate, 'Asia/Seoul', 'HH:mm');
        } else {
            checkIn = data[row][employeeCol];
        }

        let checkOut;
        if (data[row][employeeCol + 1] instanceof Date) {
            const checkOutDate = new Date(data[row][employeeCol + 1]);
            checkOutDate.setHours(checkOutDate.getHours() + 1); // 한 시간 추가
            checkOutDate.setMinutes(checkOutDate.getMinutes() - 27); // 27분 빼기
            checkOut = Utilities.formatDate(checkOutDate, 'Asia/Seoul', 'HH:mm');
        } else {
            checkOut = data[row][employeeCol + 1];
        }

        // 근무 시간 값 가져오기
        const workHours = (data[row][employeeCol + 2] instanceof Date)
            ? Utilities.formatDate(data[row][employeeCol + 2], 'Asia/Seoul', 'HH:mm')
            : data[row][employeeCol + 2];

        attendance[dateStr] = {
          checkIn: checkIn || null,
          checkOut: checkOut || null,
          workHours: workHours || 0
        };
        
        // 근무일 및 시간 계산
        if (workHours > 0) {
          workingDays++;
          totalHours += workHours;
        }
      }
    }
    
    Logger.log(`총 근무일: ${workingDays}, 총 근무시간: ${totalHours}`);

    // 요약 정보 섹션 찾기
    let summaryStartRow = -1;
    for (let row = 0; row < data.length; row++) {
      if (data[row][0] === '근무 요약 정보') {
        summaryStartRow = row;
        break;
      }
    }
    
    // 요약 정보가 없으면 기본 정보만 반환
    if (summaryStartRow === -1) {
      return { 
        attendance,
        summary: {
          employeeName: employee.name,
          totalHours: totalHours,
          workingDays: workingDays
        }
      };
    }
    
    // 직원 요약 정보 찾기
    let empSummaryCol = -1;
    for (let col = 2; col < data[summaryStartRow].length; col += 3) {
      if (data[summaryStartRow][col] === employee.name) {
        empSummaryCol = col;
        break;
      }
    }
    
    // 직원 요약 정보가 없으면 기본 정보만 반환
    if (empSummaryCol === -1) {
      return { 
        attendance,
        summary: {
          employeeName: employee.name,
          totalHours: totalHours,
          workingDays: workingDays
        }
      };
    }
    
    // 주차별 시간 정보 찾기
    let weeklyHours = {
      week1: 0,
      week2: 0,
      week3: 0,
      week4: 0,
      week5: 0
    };
    
    // 주차별 근무시간 찾기
    let weeklyRowStart = -1;
    for (let row = summaryStartRow; row < data.length; row++) {
      if (data[row][empSummaryCol] === '구분' && data[row][empSummaryCol + 1] === '시간') {
        weeklyRowStart = row + 1;
        break;
      }
    }
    
    // 주차별 시간 데이터 수집
    if (weeklyRowStart !== -1) {
      for (let week = 0; week < 5; week++) {
        const row = weeklyRowStart + week;
        if (row < data.length && data[row][empSummaryCol] === `${week + 1}주차`) {
          weeklyHours[`week${week + 1}`] = data[row][empSummaryCol + 1] || 0;
        }
      }
    }
    
    // 결과 반환 - 시간 관련 정보만 포함
    const result = {
      attendance,
      summary: {
        employeeName: employee.name,
        totalHours: totalHours,
        workingDays: workingDays,
        weeklyHours: weeklyHours
      }
    };
    
    Logger.log("결과 객체 생성 완료 (급여 정보 제외)");
    
    return result;

  } catch (e) {
    Logger.log(`getEmployeeSummaryFromSheet 오류: ${e}`);
    return { error: `데이터 처리 중 오류가 발생했습니다: ${e.message}` };
  }
}

// 데이터 유효성 검사 규칙 설정 - 출퇴근 시간 열에만 적용
function setupValidationRules(sheet, daysInMonth) {
  try {
    const employees = getEmployees();
    const dataStartRow = 3; // 실제 데이터 시작 행
    
    // daysInMonth가 유효한 값인지 확인
    if (!daysInMonth || daysInMonth <= 0) {
      Logger.log('유효하지 않은 daysInMonth 값: ' + daysInMonth);
      daysInMonth = 31; // 기본값 설정
    }
    
    employees.forEach((emp, index) => {
      const startCol = 3 + (index * 3); // 각 직원의 출근시간 열
      
      // 현재 열의 A1 표기법 얻기
      const checkInCol = getColumnLetter(startCol);
      const checkOutCol = getColumnLetter(startCol + 1);
      
      try {
        // 출근 시간 확인 규칙
        const checkInRule = SpreadsheetApp.newDataValidation()
          .requireFormulaSatisfied(`=OR(ISBLANK(${checkInCol}${dataStartRow}), ${checkInCol}${dataStartRow}="미출근", REGEXMATCH(TEXT(${checkInCol}${dataStartRow},"HH:MM"), "^[0-2][0-9]:[0-5][0-9]$"))`)
          .setAllowInvalid(false)
          .setHelpText('올바른 시간 형식을 입력하세요 (HH:MM) 또는 "미출근"')
          .build();
        
        // 퇴근 시간 확인 규칙
        const checkOutRule = SpreadsheetApp.newDataValidation()
          .requireFormulaSatisfied(`=OR(ISBLANK(${checkOutCol}${dataStartRow}), ${checkOutCol}${dataStartRow}="미퇴근", REGEXMATCH(TEXT(${checkOutCol}${dataStartRow},"HH:MM"), "^[0-2][0-9]:[0-5][0-9]$"))`)
          .setAllowInvalid(false)
          .setHelpText('올바른 시간 형식을 입력하세요 (HH:MM) 또는 "미퇴근"')
          .build();
        
        // 규칙 적용 - 출퇴근 기록 부분에만 적용 (요약 정보 섹션 제외)
        sheet.getRange(dataStartRow, startCol, daysInMonth, 1).setDataValidation(checkInRule);
        sheet.getRange(dataStartRow, startCol + 1, daysInMonth, 1).setDataValidation(checkOutRule);
      } catch (e) {
        Logger.log(`유효성 검사 규칙 설정 오류 (직원 ${emp.name}): ${e}`);
      }
    });
    
    Logger.log('유효성 검사 규칙이 성공적으로 설정되었습니다.');
    return true;
  } catch (e) {
    Logger.log(`setupValidationRules 전체 오류: ${e}`);
    return false;
  }
}

// 열 번호를 Excel 열 문자로 변환하는 함수 (예: 1 -> A, 2 -> B, 27 -> AA, ...)
function getColumnLetter(columnNumber) {
  try {
    if (!columnNumber || columnNumber <= 0) {
      Logger.log(`유효하지 않은 열 번호: ${columnNumber}, 기본값 'A' 반환`);
      return 'A';
    }
    
    let columnLetter = '';
    let tempColumnNumber = columnNumber;
    
    while (tempColumnNumber > 0) {
      let modulo = (tempColumnNumber - 1) % 26;
      columnLetter = String.fromCharCode(65 + modulo) + columnLetter;
      tempColumnNumber = Math.floor((tempColumnNumber - modulo - 1) / 26);
    }
    
    return columnLetter;
  } catch (e) {
    Logger.log(`getColumnLetter 오류: ${e}`);
    return 'A'; // 오류 발생시 기본값 반환
  }
}

// 근무 시간 계산 함수
function calculateHours(checkInTime, checkOutTime) {
  try {
    if (!checkInTime || !checkOutTime) return null;
    if (checkInTime === "미출근" || checkOutTime === "미퇴근") return null;
    
    // 시간 문자열을 분으로 변환 (HH:MM 형식)
    function timeToMinutes(timeStr) {
      const parts = String(timeStr).trim().split(':');
      return parseInt(parts[0], 10) * 60 + parseInt(parts[1], 10);
    }
    
    // 출퇴근 시간을 분으로 변환
    const checkInMinutes = timeToMinutes(checkInTime);
    const checkOutMinutes = timeToMinutes(checkOutTime);
    
    // 근무 시간 계산 (분)
    let workMinutes = checkOutMinutes - checkInMinutes;
    
    // 퇴근 시간이 출근 시간보다 이른 경우 (다음날 퇴근 가정)
    if (workMinutes < 0) {
      workMinutes += 24 * 60;
    }
    
    // 시간과 분으로 변환
    const hours = Math.floor(workMinutes / 60);
    const minutes = workMinutes % 60;
    
    return `${hours}시간 ${minutes}분`;
  } catch (e) {
    Logger.log(`근무 시간 계산 오류: ${e}`);
    return null;
  }
}

// 서버 로그 확인용 함수
function checkLogs() {
  const now = new Date();
  const currentYear = now.getFullYear();
  const currentMonth = now.getMonth();
  
  Logger.log(`현재 서버 시간: ${now}`);
  Logger.log(`현재 연도/월: ${currentYear}년 ${currentMonth + 1}월`);
  
  const result = getFormattedRecords(currentYear, currentMonth);
  
  return "로그 출력 완료. Apps Script 편집기의 '실행 > 로그 보기' 메뉴에서 확인하세요.";
}

// 더 안정적인 근무 기록 포맷팅 함수
function getFormattedRecords(year, month) {
  try {
    // 입력된 년/월 확인 및 보정
    if (year === undefined || isNaN(parseInt(year)) || month === undefined || isNaN(parseInt(month))) {
      Logger.log(`잘못된 매개변수: year=${year}, month=${month}, 현재 날짜로 기본값 설정`);
      const now = new Date();
      year = now.getFullYear();
      month = now.getMonth() + 1; // getMonth()는 0부터 시작하므로 +1
    } else {
      year = parseInt(year);
      month = parseInt(month);
    }

    Logger.log(`처리 중인 데이터: ${year}년 ${month}월`);

    // 스프레드시트 접근
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName('출퇴근기록');
    
    if (!sheet) {
      Logger.log('출퇴근기록 시트를 찾을 수 없습니다.');
      return {};
    }
    
    // 데이터 가져오기
    const data = sheet.getDataRange().getValues();
    Logger.log(`가져온 행 수: ${data.length}`);

    if (data.length <= 1) {
      Logger.log('데이터가 없거나 헤더만 있습니다.');
      return {};
    }

    // 결과 저장 객체 (날짜별 정리)
    const dailyRecords = {};

    // 헤더 확인 (열 인덱스 확인)
    const headers = data[0];
    Logger.log(`헤더: ${headers.join(', ')}`);

    const columnMap = {
      날짜: headers.indexOf("출근날짜") !== -1 ? headers.indexOf("출근날짜") : headers.indexOf("날짜"),
      이름: headers.indexOf("이름"),
      출근시간: headers.indexOf("출근시간"),
      퇴근시간: headers.indexOf("퇴근시간"),
      비고: headers.indexOf("비고"),
    };

    Logger.log(`열 인덱스: ${JSON.stringify(columnMap)}`);

    // 헤더를 제외한 모든 행 처리
    for (let i = 1; i < data.length; i++) {
      const row = data[i];

      if (!row || !row[columnMap.날짜]) continue;

      let recordDate = row[columnMap.날짜];
      if (!(recordDate instanceof Date)) {
        recordDate = new Date(row[columnMap.날짜]);
        if (isNaN(recordDate.getTime())) {
          Logger.log(`유효하지 않은 날짜 (행 ${i + 1}): ${row[columnMap.날짜]}`);
          continue;
        }
      }

      const recordYear = recordDate.getFullYear();
      const recordMonth = recordDate.getMonth() + 1;

      if (recordYear === year && recordMonth === month) {
        const dateStr = Utilities.formatDate(recordDate, 'Asia/Seoul', 'yyyy-MM-dd');
        const employeeName = row[columnMap.이름] || '이름없음';
        const checkIn = row[columnMap.출근시간] || null;
        const checkOut = row[columnMap.퇴근시간] || null;
        const note = columnMap.비고 >= 0 ? (row[columnMap.비고] || '') : '';

        if (!dailyRecords[dateStr]) dailyRecords[dateStr] = {};
        if (!dailyRecords[dateStr][employeeName]) dailyRecords[dateStr][employeeName] = [];

        const record = { checkIn, checkOut, note };

        if (checkIn && checkOut && checkIn !== '미출근' && checkOut !== '미퇴근') {
          try {
            record.workHours = calculateHours(checkIn, checkOut);
          } catch (calcError) {
            Logger.log(`근무시간 계산 오류 (행 ${i + 1}): ${calcError}`);
            record.workHours = '계산 오류';
          }
        } else if (checkIn === '미출근' || checkOut === '미퇴근') {
          record.workHours = '계산 불가';
        }

        dailyRecords[dateStr][employeeName].push(record);
      }
    }

    Logger.log(`처리된 날짜 수: ${Object.keys(dailyRecords).length}`);
    return dailyRecords;
  } catch (error) {
    Logger.log(`getFormattedRecords 전체 오류: ${error.stack || error.toString()}`);
    return {};
  }
}

// 요약 정보 업데이트
function updateSummary() {
  const summaryFields = {
    totalHours: '-',
    workingDays: '-',
    totalSalary: '-',
    averageHours: '-'
  };

  // 요약 정보 로딩 표시
  Object.keys(summaryFields).forEach(field => {
    document.getElementById(field).textContent = '로딩...';
  });

  // 서버에서 요약 데이터 가져오기
  google.script.run
    .withSuccessHandler(function(summary) {
      // 시트에서 계산된 값을 그대로 표시
      document.getElementById('totalHours').textContent = summary.totalHours;
      document.getElementById('workingDays').textContent = summary.workingDays;
      document.getElementById('totalSalary').textContent = `￦${parseInt(summary.totalSalary).toLocaleString()}`;
      document.getElementById('averageHours').textContent = summary.averageHours;
    })
    .withFailureHandler(function(error) {
      // 에러 시 기본값 표시
      Object.keys(summaryFields).forEach(field => {
        document.getElementById(field).textContent = summaryFields[field];
      });
    })
    .getEmployeeSummaryFromSheet(selectedMonth, selectedEmployeeId);
}

// 미퇴근 처리 함수 
function checkAndMarkMissingCheckouts() {
  try {
    // 1. 현재 월의 출퇴근 시트 가져오기
    const now = new Date();
    const currentMonth = now.getMonth() + 1;
    const sheet = getAttendanceSheet(currentMonth);
    
    if (!sheet) {
      Logger.log(`시트를 찾을 수 없음: ${currentMonth}월_출퇴근기록`);
      return false;
    }
    
    // 2. 전날 날짜 계산
    const yesterday = new Date(now);
    yesterday.setDate(yesterday.getDate() - 1);
    const yesterdayStr = Utilities.formatDate(yesterday, 'Asia/Seoul', 'yyyy-MM-dd');
    
    Logger.log(`전날 미퇴근 처리 시작: ${yesterdayStr}`);
    
    // 3. 시트 데이터 가져오기
    const data = sheet.getDataRange().getValues();
    let updatedCount = 0;
    
    // 4. 전날 행 찾기
    let yesterdayRow = -1;
    for (let row = 2; row < data.length; row++) {
      if (data[row][0] instanceof Date) {
        const rowDateStr = Utilities.formatDate(data[row][0], 'Asia/Seoul', 'yyyy-MM-dd');
        if (rowDateStr === yesterdayStr) {
          yesterdayRow = row;
          break;
        }
      }
    }
    
    if (yesterdayRow === -1) {
      Logger.log(`전날(${yesterdayStr}) 데이터를 찾을 수 없음`);
      return false;
    }
    
    // 5. 직원별 출퇴근 열 찾기
    const employeeColumns = {};
    for (let col = 2; col < data[0].length; col += 3) {
      const empName = data[0][col];
      if (empName && !['날짜', '요일'].includes(empName)) {
        // 각 직원의 출근/퇴근 열 저장
        employeeColumns[empName] = {
          checkInCol: col, 
          checkOutCol: col + 1
        };
      }
    }
    
    // 6. 각 직원의 미퇴근 확인
    for (const empName in employeeColumns) {
      const checkInCol = employeeColumns[empName].checkInCol;
      const checkOutCol = employeeColumns[empName].checkOutCol;
      
      // 출근 기록은 있고 퇴근 기록이 없는 경우
      const checkInValue = data[yesterdayRow][checkInCol];
      const checkOutValue = data[yesterdayRow][checkOutCol];
      
      if (checkInValue && checkInValue !== '미출근' && 
          (!checkOutValue || checkOutValue === '' || checkOutValue === '미퇴근')) {
        
        // 미퇴근 처리
        Logger.log(`${empName} 미퇴근 처리 (행: ${yesterdayRow+1})`);
        sheet.getRange(yesterdayRow + 1, checkOutCol + 1).setValue('미퇴근');
        updatedCount++;
      }
    }
    
    Logger.log(`미퇴근 처리 완료: ${updatedCount}건`);
    return updatedCount > 0;
    
  } catch (e) {
    Logger.log(`미퇴근 처리 오류: ${e.toString()}`);
    return false;
  }
}


// 두 달 전 시트 삭제 
function deleteOldSheets() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheets = ss.getSheets();
  
  const now = new Date();
  const currentMonth = now.getMonth() + 1; // 1-based (1~12)
  
  let deletedCount = 0;
  
  sheets.forEach(function(sheet) {
    const sheetName = sheet.getName();
    // "N월_출퇴근기록" 형식의 시트 찾기
    const match = sheetName.match(/^(\d+)월_출퇴근기록$/);
    
    if (match) {
      const sheetMonth = parseInt(match[1]);
      
      // 두 달 전 시트 계산 (현재가 4월이면 2월 이전 시트)
      let twoMonthsAgo = currentMonth - 2;
      
      // 1월, 2월인 경우 조정
      if (twoMonthsAgo <= 0) {
        twoMonthsAgo += 12;
      }
      
      // 두 달 전 이전 시트만 삭제 (현재 4월이면 1, 2월 시트 삭제)
      if (sheetMonth <= twoMonthsAgo) {
        // 바로 지우지 말고 확인 로그 먼저 출력
        Logger.log(`삭제 예정 시트: ${sheetName} (현재: ${currentMonth}월, 기준: ${twoMonthsAgo}월 이전)`);
        
        try {
          ss.deleteSheet(sheet);
          deletedCount++;
          Logger.log(`시트 삭제됨: ${sheetName}`);
        } catch (e) {
          Logger.log(`시트 삭제 오류: ${sheetName}, 오류: ${e.toString()}`);
        }
      }
    }
  });
  
  return `${deletedCount}개의 이전 시트가 삭제되었습니다.`;
}

// 출근 데이터를 보여줄 달력 렌더링 함수
function renderCalendar() {
 const calendarBody = document.getElementById('calendarBody');
 calendarBody.innerHTML = '';
 
 const firstDay = new Date(selectedYear, selectedMonth, 1); 
 const lastDay = new Date(selectedYear, selectedMonth + 1, 0);
 const daysInMonth = lastDay.getDate();
 
 // 달력 기본 구조 생성
 let startingDayOfWeek = firstDay.getDay();
 if (startingDayOfWeek === 0) startingDayOfWeek = 7;
 startingDayOfWeek -= 1;
 
 let date = 1;
 let weekNumber = 1;
 
 // 달력 구조 생성
 for (let i = 0; i < 6; i++) {
   if (date > daysInMonth) break;
   
   const row = document.createElement('tr');
   
   // 주차 추가 
   const weekCell = document.createElement('td');
   weekCell.innerHTML = `
     <div class="date-cell week-number" id="week-header-${weekNumber}">
       <span class="date-number">${weekNumber}주</span>
     </div>`;
   row.appendChild(weekCell);

   // 날짜 추가
   for (let j = 0; j < 7; j++) {
     const cell = document.createElement('td');
     cell.className = `week-${weekNumber}`;
     
     if (i === 0 && j < startingDayOfWeek || date > daysInMonth) {
       row.appendChild(cell);
     } else {
       const dateStr = `${selectedYear}-${String(selectedMonth + 1).padStart(2, '0')}-${String(date).padStart(2, '0')}`;
       const isWeekend = j === 6;
       
       cell.innerHTML = `
         <div class="date-cell">
           <span class="date-number${isWeekend ? ' weekend' : ''}">${date}</span>
         </div>
         <div class="records-container" id="records-${dateStr}"></div>
       `;
       
       row.appendChild(cell);
       date++;
     }
   }
   
   calendarBody.appendChild(row);
   if (j === 5) weekNumber++;
 }

 // 선택된 직원의 데이터 표시
 if (selectedEmployeeId !== 'all') {
   displayEmployeeAttendance();
 }
}

// 선택된 직원의 출퇴근 데이터 표시
function displayEmployeeAttendance() {
 // 기존 데이터 초기화
 document.querySelectorAll('.records-container').forEach(container => {
   container.innerHTML = '';
 });
 
 // 직원 데이터 표시
 Object.entries(attendanceData).forEach(([dateStr, records]) => {
   const selectedEmployee = employeeData.find(e => e.id == selectedEmployeeId);
   if (!selectedEmployee) return;

   const record = records[selectedEmployee.name];
   if (!record) return;

   const container = document.getElementById(`records-${dateStr}`);
   if (!container) return;

   // 근무 기록 표시
   const workRecord = document.createElement('div');
   workRecord.className = 'work-record';
   workRecord.innerHTML = `
     <div class="work-time">
       ${record.checkIn || ''} → ${record.checkOut || ''}
     </div>
     <div class="work-hours">
       ${record.workHours || ''}
     </div>
   `;
   container.appendChild(workRecord);
 });



}

// 직원 데이터 표시
function displayEmployeeData() {
  const selectedEmployee = employeeData.find(e => e.id == selectedEmployeeId);
  if (!selectedEmployee) return;

  // 각 날짜별 컨테이너에 데이터 표시
  Object.entries(attendanceData).forEach(([date, records]) => {
    const record = records[selectedEmployee.name];
    if (!record) return;

    const container = document.getElementById(`records-${date}`);
    if (!container) return;

    // 근무 기록 표시 - 시트에서 계산된 값 사용
    container.innerHTML = `
      <div class="work-record">
        <div class="work-time">${record.checkIn || ''} → ${record.checkOut || ''}</div>
        <div class="work-hours">${record.workHours || ''}</div>
      </div>
    `;
  });
}

// 직원 선택 이벤트 수정
function setupEmployeeSelection() {
  document.getElementById('employeeList').addEventListener('click', function(e) {
    if (e.target.tagName === 'LI') {
      // 선택 UI 업데이트
      const items = this.getElementsByTagName('li');
      for (let i = 0; i < items.length; i++) {
        items[i].classList.remove('active');
      }
      e.target.classList.add('active');
      
      // 선택된 직원 ID 저장
      selectedEmployeeId = e.target.getAttribute('data-id');
      
      // 달력 업데이트
      renderCalendar();
      
      // 요약 정보 업데이트
      displaySummary();
    }
  });
}


// 시간을 10분 단위로 반올림/내림하는 함수
function roundTimeToTenMinutes(date) {
  const minutes = date.getMinutes();
  const remainder = minutes % 10;
  
  // 분을 10분 단위로 조정
  if (remainder < 5) {
    // 1~4분은 내림 (예: 9:11 → 9:10)
    date.setMinutes(minutes - remainder);
  } else {
    // 5~9분은 올림 (예: 9:15 → 9:20)
    date.setMinutes(minutes + (10 - remainder));
  }
  
  // 초는 항상 0으로 설정
  date.setSeconds(0);
  date.setMilliseconds(0);
  
  return date;
}
